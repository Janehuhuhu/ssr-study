## 常见问题

### 1. 什么是 SSR? 和 CSR 的区别
`Server Side Rendering` 服务端渲染，由服务器进行渲染并返回给客户端渲染完成的`html`, 最后在浏览器端将静态的 `HTML`“激活”(hydrate) 为能够交互的客户端应用。

对于 `html` 的加载，以 `React` 为例，我们习惯的做法是加载 `js` 文件中的 `React` 代码，去生成页面渲染，同时， `js` 也完成页面交互事件的绑定，这样的一个过程就是 `CSR（客户端渲染）。`

但如果这个 `js` 文件比较大的话，加载起来就会比较慢，到达页面渲染的时间就会比较长，导致首屏白屏。这时候，`SSR`（服务端渲染）就出来了：由服务端直接生成 `html` 内容返回给浏览器渲染首屏内容。

但是服务端渲染的页面交互能力有限，如果要实现复杂交互，还是要通过引入 `js` 文件来辅助实现，我们把页面的展示内容和交互写在一起，让代码执行两次，这种方式就叫同构(同时运行在服务端和客户端)。

`CSR` 和 `SSR` 的区别在于，最终的 `html` 代码是从客户端添加的还是从服务端。
<br>

### 2. SSR 的优缺点
- 优点
  - 更好的 `SEO`： 因为 `SPA` 页面的内容是通过 `Ajax` 获取，而搜索引擎爬取工具并不会等待 `Ajax` 异步完成后再抓取页面内容，所以在 `SPA` 中是抓取不到页面通过 `Ajax` 获取到的内容；而 `SSR` 是直接由服务端返回已经渲染好的页面（数据已经包含在页面中），所以搜索引擎爬取工具可以抓取渲染好的页面；

  - 首屏加载更快： `SPA` 会等待所有 `Vue` 编译后的 `js` 文件都下载完成后，才开始进行页面的渲染，文件下载等需要一定的时间等，所以首屏渲染需要一定的时间；`SSR` 直接由服务端渲染好页面直接返回显示，无需等待下载 `js` 文件及再去渲染等，所以 `SSR` 有更快的内容到达时间；

- 缺点
  - 更多的开发条件限制： 例如服务端渲染只支持 `beforCreate` 和 `created` 两个钩子函数，这会导致一些外部扩展库需要特殊处理，才能在服务端渲染应用程序中运行；并且与可以部署在任何静态文件服务器上的完全静态单页面应用程序 `SPA` 不同，服务端渲染应用程序，需要处于 `Node.js server` 运行环境；

  - 更大的服务器负载：在 `Node.js` 中渲染完整的应用程序，显然会比仅仅提供静态文件的 `server` 更加大量占用 `CPU` 资源，因此如果你预料在高流量环境 ( high traffic ) 下使用，请准备相应的服务器负载，并明智地采用缓存策略。

<br>

### 3. SSR 实现过程

<br>

### 4. SSR 比 CSR 快吗
首屏渲染 `SSR` 比 `CSR` 快，加载其他页面时，`SSR` 会从头重新加载，而 `SPA` 则只加载一部分模块，甚至提前与加载组件

<br>

### 5. 为什么 SSR 首屏渲染快
- 相对于 CSR 仅有一次 http 请求
- js 加载时间

<br>

### 6. 同构渲染的概念？
同构渲染，即同一套代码即可以在服务端渲染，也可以在客户端渲染。当首次访问时，使用服务端渲染，为我们返回已经渲染完成的最终的 `HTML` 页面，这样同时解决了首屏白屏问题以及 `SEO` 问题。此后当我们进行交互时，使用客户端渲染。`HTML、CSS、JS` 等资源都不需要再重新请求，只需要通过 `ajax/websocket` 等途径获取数据，再客户端完成渲染过程

<br>

### 7. 常见同构渲染框架
- Next: `React` 框架，允许使用 `React` 构建 `SSR` 和静态 `web` 应用
- Nuxt: 基于 `Vue` 的通用应用框架，预设了利用 `Vue` 开发服务端渲染的应用所需要的各种配置，主要关注的是应用的 `UI` 渲染
- Nest:是一个渐进式 `Node` 框架,深受 `Angular` 的启发。用于构建高效，可扩展的`Node` 服务器端应用程序的框架